# 优化

## 11/21

- [x] 向客户端发送自身share时的查询mysql语句可合并

## 11/22

- [x] 将客户端中的go_share功能分离出一个share_server

## 11/23

- [x] 优化客户端中的详情显示
- [x] 优化服务器，只向客户端传递用户id，用户再在客户端的sqllite中寻找是否存在对应的名称等信息，如果不存在则再向服务器进行请求
- [x] 优化服务器，将用户信息存储在mysql中，直接在mysql进行查找用户信息

## 12/3

- [x] 优化客户端，将文字从label改为rich_text
- [ ] 优化详情列表中的发表评论

## 12/4

- [x] 优化客户端，将语音消息接入到声音服务器中

## 12/7

- [x] 启用多线程将发送图片时的处理放在其他线程中，减少客户端的卡顿

## 12/8

- [x] 将客户端中解析protobuf放入网络线程中，总体将整个程序分为以下线程：主线程（ui控制），网络线程（接受并解析protobuf），发送线程（资源的加载以及发送）

## 12/11

- [x] 优化客户端接受流程，例如图片，将image由二进制转换为Image的过程放在resourceserver中执行
- [x] 优化客户端整体结构，调整为主线程(ui控制)，网络接受线程(接受并解析protobuf)，网络发送线程(向服务器发送消息)，资源加载线程(通过此线程加载资源)
- [x] 优化截图程序与godot的交互，通过管道进行沟通而不是每次都启动一遍程序，在godot退出时也使他退出

## 12/12

- [x] 在复制图片至剪切板程序中添加心跳检测，每五秒检测一次godot主程序是否存在，否则退出

## 1/1

- [x] 更新主页面侧边栏图标

## 1/4

- [x] 优化客户端发送点赞的系统，由原来在每个share_unit中各自发送集成到一个like_server中

# 功能

## 11/21

- [x] 完成客户端中显示自身share详情内容
- [x] 将客户端中的我的share功能独立出来，且将翻页变为一直下拉功能

## 11/22

- [x] 完成创建评论，获得评论

## 12/4

- [x] 创建声音服务器，将所有声音由其控制

## 12/7

- [x] 完成发送图片功能，复制图片至剪切板，粘贴图片

## 12/18

- [x] 添加登录效果

## 1/1

- [x] 完成tips的显示，错误为需要手动确认，tips只是自动跳出淡出

## 1/2

- [x] 完成服务器以及客户端的点赞系统

## 1/4

- [x] 添加在share_detail面板中的like
- [x] 添加share中的刷新

# 修复bug

## 12/12

* 修复了share的detail无法显示名称，漏写了在shareunit中从本地数据库中获取到当前用户信息时更新user_name的功能

## 12/13

* 修复了服务器中查询用户信息的函数的错误查询

## 12/29

* 修复在加载图片时图片容器显示关闭按钮

## 1/4

* 点赞在redis中仍然会出现数量和列表不一致的现象

# 功能详细

## 点赞

* 将点赞分为两个表，一个是点赞的具体信息，对应点赞的内容id和点赞的用户id，一个记录内容对应的点赞数，当执行一次点赞时，会首先向缓存数据库请求数据，如果没有对应的数据再向数据库请求数据，先对redis缓存进行操作修改数据，然后向一张临时表中存放修改的信息，当表中的信息数量超过设定值后或者超过一定时间后，将表内的数据聚合写入mysql主表中，减少io。

# V0.4

## v0.4.1

* 添加了点赞系统
* 添加了加载动画
* 修复部分bug



```go
redisConn := redisQQ.Pool.Get()
defer redisConn.Close()
//将用户点赞信息写入mysql中
info := mysqlQQ.ShareLikeInfo{}
result := mysqlQQ.Db.Where("share_id = ?", likeMsg.ContentId).Where("user_id = ?", likeMsg.UserId).First(&info)
if result.Error != nil {
    if errors.Is(result.Error, gorm.ErrRecordNotFound) {
       // 记录不存在，创建新记录
       fmt.Println("记录不存在，创建新记录")
       info = mysqlQQ.ShareLikeInfo{
          ShareID: uint(likeMsg.ContentId),
          UserID:  likeMsg.UserId,
          IsLike:  likeMsg.Result,
       }
       mysqlQQ.Db.Create(&info)
    } else {
       // 处理其他错误
       fmt.Println("Error:", result.Error)
    }
} else {
    //当数据库中存储的喜欢和发送过来的喜欢数据一样，则直接返回
    if likeMsg.Result == info.IsLike {
       fmt.Println("发送的数据与原数据冲突，函数返回")
       return
    }
    fmt.Println("更新数据库数据")
    info.IsLike = likeMsg.Result
    info.ShareID = uint(likeMsg.ContentId)
    info.UserID = likeMsg.UserId
    mysqlQQ.Db.Model(&info).Where("share_id = ?", info.ShareID).Where("user_id = ?", info.UserID).Update("IsLike", likeMsg.Result)
}
//检查redis中是否已经有数据
key := strconv.Itoa(int(likeMsg.ContentId))
_, err := redis.Int(redisConn.Do("get", "share_like_counts"+key))
if err != nil {
    //在redis中没有数据,将从数据库中获取的所有的点赞用户数据和点赞量存入redis中,并设置过期时间
    shareLikeCountsInfo := mysqlQQ.ShareLikeCountsInfo{}
    mysqlQQ.Db.Where("share_id = ?", likeMsg.ContentId).First(&shareLikeCountsInfo)
    fmt.Println("redis中没有数据，获得原share数量：", shareLikeCountsInfo.Counts)
    //直接将查询到的数据在数据库和缓存中进行更新
    if likeMsg.Result == true {
       shareLikeCountsInfo.Counts += 1
       redisConn.Do("set", "share_like_counts"+key, shareLikeCountsInfo.Counts)
       mysqlQQ.Db.Save(&shareLikeCountsInfo)
    } else {
       shareLikeCountsInfo.Counts -= 1
       redisConn.Do("set", "share_like_counts"+key, shareLikeCountsInfo.Counts)
       mysqlQQ.Db.Save(&shareLikeCountsInfo)
    }
    fmt.Println("更新后数量：", shareLikeCountsInfo.Counts)
    userList := make([]mysqlQQ.ShareLikeInfo, 0)
    mysqlQQ.Db.Where("share_id = ?", likeMsg.GetContentId()).Where("is_like = ?", true).Find(&userList)
    redisConn.Send("multi")
    for _, v := range userList {
       redisConn.Send("sadd", "share_like"+key, v.UserID)
    }
    redisConn.Send("expire", "share_like_counts"+key, 600)
    redisConn.Send("expire", "share_like"+key, 600)
    _, err = redisConn.Do("exec")
    if err != nil {
       fmt.Println("multi error = ", err)
       return
    }
} else {
    currentCount, err := redis.Int(redisConn.Do("get", "share_like_counts"+key))
    fmt.Println("redis中有数据，当前数据量为", currentCount)
    if err != nil {
       fmt.Println("get currentCount err = ", err)
       return
    }
    if likeMsg.Result == true {
       redisConn.Do("set", "share_like_counts"+key, currentCount+1)
       redisConn.Do("sadd", "share_like"+key, likeMsg.UserId)
    } else {
       redisConn.Do("set", "share_like_counts"+key, currentCount-1)
       redisConn.Do("srem", "share_like"+key, likeMsg.UserId)
    }
    redisConn.Do("expire", "share_like_counts"+key, 600)
    redisConn.Do("expire", "share_like"+key, 600)
    //将修改的点赞数量再放入redis中，来进行聚合写入
    currentCount, err = redis.Int(redisConn.Do("get", "aggregate_share_counts"+key))
    //当没有查到当前数据
    if err != nil {
       currentCount = 0
    }
    if likeMsg.Result == true {
       currentCount += 1
    } else {
       currentCount -= 1
    }
    redisConn.Do("set", "aggregate_share_counts"+key, currentCount)
}
```
